---
title: "Jitter test in ADMB using R"
---

This tutorial will walk through how to conduct a jitter test in ADMB. The fastest way to run a jitter test in ADMB is to run it through R so you do not need to manually change the initial parameter values each iteration. However, this will require some extra steps to set up your code in both ADMB and R.

## admb2r.cpp instructions

This tutorial (and the most of the stock assessment models in the Great Lakes region) requires this package called "admb2r". This is a collection of AD Model Builder routines for saving complex data structures into a file that can be read into R. This cannot be automatically downloaded in the newer ADMB versions. You can keep a "admb2r.cpp" file where your .tpl and .dat files are, however that requires copying and pasting it every time you want to run a ADMB model.

 

These are instructions for using admb2r.cpp permanently. Copy admb2r.cpp to both the following folders:

-   admb/include

-   admb/include/contrib

 

A copy of admb2r.cpp is [here](https://github.com/admb-project/admb/blob/main/contrib/admb2r/admb2r.cpp). Once this is done you will not need to add admb2r.cpp to every project folder. This has been tested on Linux Mint, Windows, and Mac.

## Set up ADMB

You will need to modify your ADMB code. If possible, you should download the most recent ADMB version [here](https://www.admb-project.org/). This recent version will print out additional error messages and allow you to run additional functions (like `get_hessian()`).

### Surplus production model - .tpl and .dat files

In this tutorial, we will look at a surplus production model. The .dat file name is called `surp_prod1.dat`. You can name the .tpl file anything, but in this tutorial, it will be called `surp_prod_jitter.tpl`.

```{r, eval = FALSE}
DATA_SECTION

!! ad_comm::change_datafile_name("surp_prod1.dat");
 init_int fyear;
 init_int lyear;
 init_vector cat(fyear,lyear);
 init_vector cpue(fyear,lyear);


PARAMETER_SECTION

 init_number log_r;
 init_number log_q;
 init_number log_K;
 init_number log_sd_cpue;
 init_vector log_F(fyear,lyear);
 
 number r;
 number q;
 number K;
 number sd_cat;
 number sd_cpue;

 vector bio(fyear,lyear+1);
 vector cat_hat(fyear,lyear);
 vector cpue_hat(fyear,lyear);
 vector expl_out(fyear,lyear);
 vector F(fyear,lyear);
 
 objective_function_value jnll;


INITIALIZATION_SECTION

 log_r -0.6
 log_q -1
 log_K 8.5
 log_sd_cpue -1
 log_F 1


PROCEDURE_SECTION

 int t;
 dvariable expl;
 
 // Convert from log to normal space
 r = mfexp(log_r);
 q = mfexp(log_q);
 K = mfexp(log_K);
 F = mfexp(log_F);
 sd_cat = 0.05;
 sd_cpue = mfexp(log_sd_cpue);

 // Project the model forward
 bio(fyear) = K;
 for (t=fyear; t<=lyear; t++) {
   expl = 1.0/(1.0+F(t));
   bio(t+1) = bio(t) + r*bio(t)*(1.0-bio(t)/K) - expl*bio(t);
   cat_hat(t) = expl * bio(t);
   expl_out(t) = expl;
   cpue_hat(t) = q * bio(t);
  } 
  
 // Compute the likelihoods  
 jnll = 0;
 for (t=fyear; t<=lyear; t++) {
  jnll += 0.5 * square(log(cat(t)/cat_hat(t)) / sd_cat) + log(sd_cat);
  jnll += 0.5 * square(log(cpue(t)/cpue_hat(t)) / sd_cpue) + log(sd_cpue);
 }

 
GLOBALS_SECTION

  #include <admodel.h>
  #include <admb2r.cpp>


REPORT_SECTION
 open_r_file("out.rdat", 6, -999);
  wrt_r_complete_vector("obs_cat", cat);
  wrt_r_complete_vector("obs_cpue", cpue);
  wrt_r_complete_vector("est_bio", bio);
  wrt_r_complete_vector("est_cat", cat_hat);
  wrt_r_complete_vector("est_cpue", cpue_hat);
  wrt_r_complete_vector("est_expl", expl_out);
  wrt_r_item("jnll", jnll);
 close_r_file();


FINAL_SECTION

  // extract Hessian matrix
  open_r_file("hessian.rdat");
    open_r_matrix("hessian");
      wrt_r_matrix(get_hessian(),1,1);
    close_r_matrix();
  close_r_file();
```

This tutorial will not go through the surplus production model in details, but the leading parameters are $r$, $K$, $q$, $F$, and $sd_{cpue}$. Note that there is a standard deviation for the catch observations, but that is fixed in this model ($sd_{catch}$ = 0.05) The objective function (`jnll`) is the total objective function, which is the sum of the data likelihood for catch and index (CPUE) data, which follow a log normal distribution.

 

The default data file name is different than the .tpl file name. This is done using this command:

```{r, eval = FALSE}
!! ad_com::change_datafile_name("surp_prod1.dat");
```

The data will be read from `surp_prod1.dat`. This is useful when you have many variants of the model that use the same data. This trick will be useful for the jitter test.

 

You can copy and paste the `surp_prod1.dat` here:

```{r, eval = FALSE}
# first year
1965

# last year
1988

# Catch
93.51
212.444
195.032
382.712
320.43
402.467
365.557
606.084
377.642
318.836
309.374
389.02
276.901
254.251
170.006
97.181
90.523
176.532
216.181
228.672
212.177
231.179
136.942
212

# Index
1.78
1.31
0.91
0.96
0.88
0.9
0.87
0.72
0.57
0.45
0.42
0.42
0.49
0.43
0.4
0.45
0.55
0.53
0.58
0.64
0.66
0.65
0.61
0.63
```

### DATA_SECTION

In the surplus production example, we will jitter the following parameters: $r$, $K$, $q$, and $sd_{cpue}$.

```{r, eval = FALSE}
!! ad_comm::change_datafile_name("log_r.dat");
  init_number inlog_r;

!! ad_comm::change_datafile_name("log_K.dat");
  init_number inlog_K;

!! ad_comm::change_datafile_name("log_q.dat");
  init_number inlog_q;
  
!! ad_comm::change_datafile_name("log_sd_cpue.dat");
  init_number inlog_sd_cpue;
```

This is similar to the previous command, but here the `!! ad_com::change_datafile_name("param_name.dat")` command is reading parameter values (`param_name`) from separate .dat files. This will be important in the R script as you can rewrite this .dat file in R to produce multiple starting values that will be read in ADMB. Note that the parameter name that is being read in should be different than the one in the PARAMETER_SECTION (the ones being used in the estimation).

 

The DATA_SECTION will look like this:

```{r, eval = FALSE}
DATA_SECTION
!! ad_comm::change_datafile_name("log_r.dat");
  init_number inlog_r;

!! ad_comm::change_datafile_name("log_K.dat");
  init_number inlog_K;

!! ad_comm::change_datafile_name("log_q.dat");
  init_number inlog_q;
  
!! ad_comm::change_datafile_name("log_sd_cpue.dat");
  init_number inlog_sd_cpue;

!! ad_comm::change_datafile_name("surp_prod1.dat");
 init_int fyear;
 init_int lyear;
 init_vector cat(fyear,lyear);
 init_vector cpue(fyear,lyear);
```

### PARAMETER_SECTION

In this section, we will be overriding the starting parameter values declared in the INITIALIZATION_SECTION. This is why the parameter names above (`inparam_name`) needs to be different than the ones (`param_name`) being declared.

```{r, eval = FALSE}
!! log_r = inlog_r;
!! log_K = inlog_K;
!! log_q = inlog_q;
!! log_sd_cpue = inlog_sd_cpue;
```

This will now read what was stored in the respective .dat files as the starting value of the parameter, which will be created in R.

 

For the surplus production model, it will look like this:

```{r, eval = FALSE}
PARAMETER_SECTION

 init_number log_r;
 init_number log_q;
 init_number log_K;
 init_number log_sd_cpue;
 init_vector log_F(fyear,lyear);
 
 number r;
 number q;
 number K;
 number sd_cat;
 number sd_cpue;

 vector bio(fyear,lyear+1);
 vector cat_hat(fyear,lyear);
 vector cpue_hat(fyear,lyear);
 vector expl_out(fyear,lyear);
 vector F(fyear,lyear);
 
 objective_function_value jnll;
 
 // override starting values and read from .dat files
!! log_r = inlog_r;
!! log_K = inlog_K;
!! log_q = inlog_q;
!! log_sd_cpue = inlog_sd_cpue;
```

### INITIALIZATION_SECTION

This section should either be commented out or empty as the `param_name.dat` file will override the starting value for that parameter. This is important for the jitter test to work. It will look like this for the surplus production model:

```{r, eval = FALSE}
INITIALIZATION_SECTION

 // log_r -0.6
 // log_q -9
 // log_K 8.5
 // log_sd_cpue -1
 log_F 1
```

The next few sections (`PROCEDURE_SECTION`, `GLOBALS_SECTION`, and `REPORT_SECTION`) should be the same as the original model.

### FINAL_SECTION

In the final section, you will need to add a command to define an output file stream, write the output, and close the output file. This is using the functionality of "admb2r".

```{r, eval = FALSE}
  ofstream myout("estpars.dat",ios::app);
    myout<< inlog_r << " " << log_r << " " << inlog_q << " " << log_q << " " << inlog_K << " " << log_K << " " << inlog_sd_cpue << " " << log_sd_cpue << " " << jnll << endl;
  myout.close();
```

The `estpars.dat` file will eventually contain all the input starting values from R (`inparam_name`), estimated parameters from ADMB (`param_name`), and the objective function (`objective_function`) from ADMB. This is important as it will contain all the iterations and results of the jitter test and will be read into R as a table.

 

The `FINAL_SECTION` will look like this:

```{r, eval = FALSE}
FINAL_SECTION

  ofstream myout("estpars.dat",ios::app);
    myout<< inlog_r << " " << log_r << " " << inlog_q << " " << log_q << " " << inlog_K << " " << log_K << " " << inlog_sd_cpue << " " << log_sd_cpue << " " << jnll << endl;
  myout.close();

  // extract Hessian matrix
  open_r_file("hessian.rdat");
    open_r_matrix("hessian");
      wrt_r_matrix(get_hessian(),1,1);
    close_r_matrix();
  close_r_file();
```

### Entire ADMB example of the surplus production model

Here is the entire ADMB script for an example of conducting a jitter test with the surplus production model.

```{r, eval = FALSE}
DATA_SECTION

!! ad_comm::change_datafile_name("log_r.dat");
  init_number inlog_r;

!! ad_comm::change_datafile_name("log_K.dat");
  init_number inlog_K;

!! ad_comm::change_datafile_name("log_q.dat");
  init_number inlog_q;
  
!! ad_comm::change_datafile_name("log_sd_cpue.dat");
  init_number inlog_sd_cpue;

!! ad_comm::change_datafile_name("surp_prod1.dat");
 init_int fyear;
 init_int lyear;
 init_vector cat(fyear,lyear);
 init_vector cpue(fyear,lyear);


PARAMETER_SECTION

 init_number log_r;
 init_number log_q;
 init_number log_K;
 init_number log_sd_cpue;
 init_vector log_F(fyear,lyear);
 
 number r;
 number q;
 number K;
 number sd_cat;
 number sd_cpue;

 vector bio(fyear,lyear+1);
 vector cat_hat(fyear,lyear);
 vector cpue_hat(fyear,lyear);
 vector expl_out(fyear,lyear);
 vector F(fyear,lyear);
 
 objective_function_value jnll;

!! log_r = inlog_r;
!! log_K = inlog_K;
!! log_q = inlog_q;
!! log_sd_cpue = inlog_sd_cpue;


INITIALIZATION_SECTION

 // log_r -0.6
 // log_q -9
 // log_K 8.5 
 log_F 1


PROCEDURE_SECTION
 int t;
 dvariable expl;
 dvariable sum_sq;
 
 // Convert from log to normal space
 r = mfexp(log_r);
 q = mfexp(log_q);
 K = mfexp(log_K);
 F = mfexp(log_F);
 sd_cat = 0.05;
 sd_cpue = mfexp(log_sd_cpue);

 // Project the model forward
 bio(fyear) = K;
 for (t=fyear; t<=lyear; t++) {
   expl = 1.0/(1.0+F(t));
   bio(t+1) = bio(t) + r*bio(t)*(1.0-bio(t)/K) - expl*bio(t);
   cat_hat(t) = expl * bio(t);
   expl_out(t) = expl;
   cpue_hat(t) = q * bio(t);
  } 
  
 // Compute the likelihoods  
 jnll = 0;
 for (t=fyear; t<=lyear; t++) {
  jnll += 0.5 * square(log(cat(t)/cat_hat(t)) / sd_cat) + log(sd_cat);
  jnll += 0.5 * square(log(cpue(t)/cpue_hat(t)) / sd_cpue) + log(sd_cpue);
 }
 

GLOBALS_SECTION
  #include <admodel.h>
  #include <admb2r.cpp>


REPORT_SECTION
 open_r_file("out.rdat", 6, -999);
  wrt_r_complete_vector("obs_cat", cat);
  wrt_r_complete_vector("obs_cpue", cpue);
  wrt_r_complete_vector("est_bio", bio);
  wrt_r_complete_vector("est_cat", cat_hat);
  wrt_r_complete_vector("est_cpue", cpue_hat);
  wrt_r_complete_vector("est_expl", expl_out);
  wrt_r_item("jnll", jnll);
 close_r_file();


FINAL_SECTION

  ofstream myout("estpars.dat",ios::app);
    myout<< inlog_r << " " << log_r << " " << inlog_q << " " << log_q << " " << inlog_K << " " << log_K << " " << inlog_sd_cpue << " " << log_sd_cpue << " " << jnll << endl;
  myout.close();

  // extract Hessian matrix
  open_r_file("hessian.rdat");
    open_r_matrix("hessian");
      wrt_r_matrix(get_hessian(),1,1);
    close_r_matrix();
  close_r_file();
```

The next step is to set up a R script to run the jitter test.

## Set up R

### R helper functions

You will need these helper files to run ADMB through R:

-   [base_funs.r](https://github.com/lidach/addtools/blob/main/R/base_funs.r) - this contains three functions to read and compile a ADMB executable and run the ADMB model

    -   `compile_admb()`

    -   `read_admb()`

    -   `run_admb()`

-   [clean_admb.r](https://github.com/lidach/addtools/blob/main/R/clean_admb.r) - after you are done running your model, this will clean all the additional ADMB files in your directory.

 

Note that these functions only work for Windows (*Mac and Linux instructions are in progress*).

 

These helper functions will be loaded in R using the `source()` function (make sure these are in the same directory as the .tpl and .dat files):

```{r, eval=FALSE}
source("base_funs.r")
source("clean_admb.r")
```

### Compile and run ADMB in R

The R helper functions (`base_funs.r`) has a function (`compile_admb.r`), which will compile ADMB using a R command. The .tpl name in this tutorial is called "surp_prod_jitter".

```{r, eval = FALSE}
tpl_name <- "surp_prod_jitter" # name of the .tpl file
# compile ADMB
compile_admb(fn = tpl_name, verbose = TRUE)
```

We will include `verbose=TRUE`, which will print out the compile messages from ADMB in the R console (should be the same as running the ADMB command prompt):

 

![](images/clipboard-1943540904.png){width="1100"}

 

Next we will create new .dat files, which will contain the starting parameter values that will be read into ADMB.

```{r, eval = FALSE}
cat("-0.6", file = "log_r.dat", sep = "\n")
cat("-3", file = "log_q.dat", sep = "\n")
cat("8", file = "log_K.dat", sep = "\n")
cat("-1", file = "log_sd_cpue.dat", sep = "\n")
```

This will create four .dat files (`log_r.dat`,`log_q_dat`, `log_K.dat`, and `log_sd_cpue.dat`). You should see this in your local directory:

 

![](images/clipboard-4267604269.png){fig-align="center"}

 

The .dat files should contain each initial value that is specified (open each file and check):

-   `-0.6` for `log_r`

-   `-3` for `log_q`

-   `8` for `log_K`

-   `-1` for `log_sd_cpue`

 

Next, we will run the ADMB model using the command `run_admb()`:

```{r, eval = FALSE}
run_admb(fn = tpl_name, verbose = TRUE)
```

What prints out in the R console should look exactly like what prints out in the ADMB command prompt:

![](images/clipboard-3631222671.png){width="870"}

This should produce a result of the surplus production model (check the ".par" file).

### Set up the jitter test

Next, we will create an object called `dat`, which will show what is being read into `estpars.dat`. This `dat` object is just a check to make sure the file contains the correct values (initial starting values from R, parameter estimates from ADMB, and the objective function from ADMB).

```{r, eval = FALSE}
if (file.exists("estpars.dat")) {
  dat <- read.table("estpars.dat")
  colnames(dat) <- c("inlog_r", "log_r", "inlog_q", "log_q", "inlog_K", "log_K", "inlog_sd_cpue", "log_sd_cpue", "objn")
}
```

 

![](images/clipboard-31559888.png){width="870"}

 

We will then delete `estpars.dat` as this contains the initial run of the surplus production model. We will also create a replacement file that will have the same column names as `dat` object in R (and the same as the one created in the `FINAL_SECTION` of ADMB). We will use the `estpars.dat` file to store each iteration of the jitter test:

```{r, eval = FALSE}
# Delete any existing version of estpars.dat
if (file.exists("estpars.dat")) file.remove("estpars.dat")

# Create header for file so we know the variables.
# sep ["\n" needed for line feed]
cat("inlog_r log_r inlogq log_q inlogK log_K inlog_sd_cpue log_sd_cpue objn", file = "estpars.dat", sep = "\n")
```

This is what the `estpars.dat` file should look like:

 

![](images/clipboard-2355991714.png){width="790"}

 

Next we will create a set of starting values. We will declare how many iterations of the jitter test we would like to conduct (`nrun <- # number of iterations`). We will randomize a set of starting values for $r$, $q$, $K$, and $sd_{cpue}$ using the `rnorm()` function, and it will be randomized with a CV = 10%:

```{r, eval = FALSE}
# Define a set of starting values
nrun <- 50 # number of reruns with new values
st_log_r <- dat$log_r + rnorm(nrun, sd = 0.1)
st_log_q <- dat$log_q + rnorm(nrun, sd = 0.1)
st_log_K <- dat$log_K + rnorm(nrun, sd = 0.1)
st_log_sd_cpue <- dat$log_sd_cpue + rnorm(nrun, sd = 0.1)
```

You should get different initial parameter values (this is what `st_log_r` looks like):

 

![](images/clipboard-1341424250.png){width="1100"}

 

This is where ADMB will run 50 times in a for loop, with each iteration reading different values of $r$, $q$, $K$, and $sd_{cpue}$ from the objects ``` st_log_r,``st_log_q ```, `st_log_K`, and `st_log_sd_cpue` . We will use the `system()` function to rerun the ADMB model from the executable file (`.exe`):

```{r, eval = FALSE}
# Write out each value of the parameters and run ADMB program for each in loop
for (i in 1:length(st_log_r)) {
  cat(st_log_r[i], file = "log_r.dat", sep = "") # write one st value to file
  cat(st_log_q[i], file = "log_q.dat", sep = "") # write one st value to file
  cat(st_log_K[i], file = "log_K.dat", sep = "") # write one st value to file
  cat(st_log_sd_cpue[i], file = "log_sd_cpue.dat", sep = "") # write one st value to file
  system(paste0(tpl_name, ".exe")) # running ADMB executable (no need to recompile)
}
```

Note that we do not need to manually recompile the model from the ADMB command prompt or use the `admb` command to rerun the model. This will work on Windows computers (*Mac and Linux instructions in progress*).

### Jitter test results

Now we will read in the `estpars.dat` file, which should contain all the iterations of the jitter test with different starting values of each parameter:

```{r, eval = FALSE}
# read in and print results to console
jit_res <- read.table("estpars.dat", header = T)
jit_res
```

When you look at the `jit_res` object, it should look like this:

 

![](images/clipboard-1880361287.png){width="900"}

 

There are some things to look out for in the `jit_res` object:

-   The initial starting parameter values are different across the iterations

-   Make sure that the parameter estimates across the iterations are the same (note: there may be some rounding differences, but the estimates should not be significantly different)

-   The objective function (joint negative log likelihood in this tutorial) are the same across the iterations

 

We can also visualize the jitter test using a box plot:

```{r, eval = FALSE}
# boxplots - are there any weird shapes/outliers?
boxplot(jit_res[, c(2, 4, 6, 8, 9)])
```

![](images/clipboard-2261044788.png){fig-align="center" width="600"}

 

After conducting the jitter test, we can run these functions that will clean the extra ADMB files that were compiled throughout the process:

```{r, eval = FALSE}
# clean extra files 
clean_admb(fn = tpl_name) 
if (file.exists("estpars.dat")) file.remove("estpars.dat") 
if (file.exists("out.rdat")) file.remove("out.rdat") 
if (file.exists("hessian.rdat")) file.remove("hessian.rdat") 
if (file.exists("log_K.dat")) file.remove("log_K.dat") 
if (file.exists("log_r.dat")) file.remove("log_r.dat") 
if (file.exists("log_q.dat")) file.remove("log_q.dat") 
if (file.exists("log_sd_cpue.dat")) file.remove("log_sd_cpue.dat")
```

### Entire R script for the jitter test of the surplus production model

Here is the entire R script for an example of conducting a jitter test with the surplus production model.

```{r, eval = FALSE}
source("base_funs.r")
source("clean_admb.r")
tpl_name <- "surp_prod_jitter"

# compile ADMB
compile_admb(fn = tpl_name, verbose = TRUE)

# set initial values and source from external files
cat("-0.6", file = "log_r.dat", sep = "\n")
cat("-3", file = "log_q.dat", sep = "\n")
cat("8", file = "log_K.dat", sep = "\n")
cat("-1", file = "log_sd_cpue.dat", sep = "\n")

# run ADMB
run_admb(fn = tpl_name, verbose = TRUE)

# get parameter estimates (used for jittering)
if (file.exists("estpars.dat")) {
  dat <- read.table("estpars.dat")
  colnames(dat) <- c("inlog_r", "log_r", "inlog_q", "log_q", "inlog_K", "log_K", "inlog_sd_cpue", "log_sd_cpue", "objn")
}

# Delete any existing version of estpars.dat
if (file.exists("estpars.dat")) file.remove("estpars.dat")

# Create header for file so we know the variables.
# sep ["\n" needed for line feed]
cat("inlog_r log_r inlogq log_q inlogK log_K inlog_sd_cpue log_sd_cpue objn", file = "estpars.dat", sep = "\n")

# Define a set of starting values
nrun <- 50 # number of reruns with new values
st_log_r <- dat$log_r + rnorm(nrun, sd = 0.1)
st_log_q <- dat$log_q + rnorm(nrun, sd = 0.1)
st_log_K <- dat$log_K + rnorm(nrun, sd = 0.1)
st_log_sd_cpue <- dat$log_sd_cpue + rnorm(nrun, sd = 0.1)

# Write out each value of the parameters and run ADMB program for each in loop
for (i in 1:length(st_log_r)) {
  cat(st_log_r[i], file = "log_r.dat", sep = "") # write one st value to file
  cat(st_log_q[i], file = "log_q.dat", sep = "") # write one st value to file
  cat(st_log_K[i], file = "log_K.dat", sep = "") # write one st value to file
  cat(st_log_sd_cpue[i], file = "log_sd_cpue.dat", sep = "") # write one st value to file
  system(paste0(tpl_name, ".exe"))# running ADMB executable (no need to recompile)
}

# read in and print results to console
jit_res <- read.table("estpars.dat", header = T)
jit_res

# boxplots - are there any weird shapes/outliers?
boxplot(jit_res[, c(2, 4, 6, 8, 9)])

# clean extra files
clean_admb(fn = tpl_name)
if (file.exists("estpars.dat")) file.remove("estpars.dat")
if (file.exists("out.rdat")) file.remove("out.rdat")
if (file.exists("hessian.rdat")) file.remove("hessian.rdat")
if (file.exists("log_K.dat")) file.remove("log_K.dat")
if (file.exists("log_r.dat")) file.remove("log_r.dat")
if (file.exists("log_q.dat")) file.remove("log_q.dat")
if (file.exists("log_sd_cpue.dat")) file.remove("log_sd_cpue.dat")
```

## Jitter test interpretation

There should not be any outliers or weird shapes in the box plots (this is an example of how the box plot would look like if the jitter test fails):

 

![](images/clipboard-3263973957.png){fig-align="center" width="600"}

A failed jitter test is indicative that there is something wrong with the model:

-   Incorrect parameterization

-   Bad starting values (they may not make sense for the parameter)

-   Incorrect specification of the objective function

-   Incorrect equations

-   Data is not informative enough to estimate the parameter

 

This should be done for every parameter. In this tutorial, the jitter test was not conducted on $F$. However, to fully check the convergence of this model, the jitter test should also be conducted for $F$.
